
(lest we forget)

language/runtime:

 - "close to forth", but without much attempt to be "standards compliant"

 - word size is 32-bit? so stack elements are 32-bit. ops like + and * treat
   them as float32, but variants like i+ i* for int32 also exists?

 - the program is repeatedly executed to keep event buffers full (so your
   program gets asked to fill buffers within a time interval), but also to
   "vet" pending changes against various errors? program execution is frequent
   and execution time should be brief. besides event buffers your program also
   describes the audio graph.

 - besides the primary stack (stack) and the return stack (rstack) there is
   also the state-id stack (sstack). this is used when you insert something
   that's stateful (simple example: a biquad filter; has 4 state values [real].
   a 1000-sample delay has at least 1000 real-valued state values) so that you
   typically don't have to explicitly allocate and assign state.
   - it'll (mostly?) be used when calling words that are tagged with a "state
     auto assignment" flag, e.g. AUTOSTATE (like how words can be tagged with
     "IMMEDIATE"). this causes a unique state id to be assigned /once/, the
     first time the call is compiled, and the id gets invisibly "burned into"
     the call in the source code (probably by using \033 escapes). the id is
     pushed just before the call, and popped just after.
   - auto-assignment doesn't work in a loop, so there should also be words for
     manipulating the sstack directly
   - (editor-integration) there'll also be some "common sense" semantics when
     it comes to cut/copy-pasting code that contains invisible state tags: if
     the same state tag is found in 2+ places; prefer the existing
     (non-inserted) one, otherwise the first inserted one. the remaining get a
     new/fresh state tag.
   - abandoned syntax idea (just so I don't reinvent it): enter/leave a sstack
     scope with:
       <foo< ... >foo>
     or shorter (but doesn't check value on stack):
       <foo< ... >>
     (the motivation was that I didn't believe state tag auto-assignment to be
     possible for something like "bd*4", which then gets "garbage collected"
     (later), which again built on the assumption that a sampler has to be
     stateful?)

 - there's a heap
   - I think it should be allocate-only (no free). this is inspired by Forth
     (allot) and Ada (new). also by the fact that your program is never
     long-running (it runs in short event-buffer-filling bursts?). so freeing
     is overrated? and, in any case, dangerous?
   - by convention I think heap values should contain some kind of "cheap RTTI"
     (like: first word at address is a type enum?). this includes strings
     because they can often be used interchangably with patterns? so a word
     that accepts a pattern should also accept a string. this is requires RTTI
     (run-time type information).

 - "garbage collection": values left on the stack when your program stops
   (without errors) are "collected and promoted" if possible:
     "bd*4"
   becomes
     "bd*4" sound (x -- x)
   becomes
     "bd*4" sound out (x --)
   NOTE: i'm assuming it's possible to make a stateless sampler. if this isn't
   the case, then promoting `"bd*4"` to `"bd*4" sound` is problematic.
   (Q: what if a value cannot be promoted? like a number? throw a warning?)

 - rich strings; strings contain invisible escape sequences that contain
   additional data/metadata:
   - original source location (used for rhythmic highlighting)
   - characters can have different colors? (in general, you can choose/change
     your text color, but it can only be used semantically inside strings; e.g.
     you can make a filter that only play "redish notes", or plays them with
     higher velocity, etc)



editor:

 - when you begin inserting/typing text, it'll have a green background. if you
   delete text ([backspace]/[delete]) it'll be marked red (instead of actually
   being deleted). these are "staged changes", not yet active. you'll have
   keyboard shortcuts for:
   - committing all staged edits
   - committing one edit
   - cancelling all staged edits
   - cancelling one edit
   (probably allow committing/cancelling other people's edits too?)
   (I have a fear that deletes are going to be confusing because they just mark
   text as red... but: try it out, and possibly allow/try a version where "red
   sections" are collapsed to a single line between two character cells,
   although it only works for multiline deletes, which is weird?)

 - "obvious errors" should probably be prevented from being committed.
   - syntax errors:
     - comments that aren't closed, like `(hi!`
     - strings that aren't closed, like `"hi!`
     - word-defs that aren't closed, like `:hi ...`
     - syntax errors in if/then/else, loops, etc
   - runtime errors (if they're caught!)
     - unit tests failing
     - assertions failing
     - out-of-bounds heap accesses
     - divide-by-zeroes (unless they just make NaNs or something)



ui (main):

 - you can split your main window into areas. each area can be:
   - editor/spectator
   - debug info / "manpages"
   - settings

 - debug/manpages
   - view stack under cursor; set an entrypoint (or choose entire program?); if
     program passes 20 times under the cursor (a loop) it says "1/20" and you
     can jump forth and back between iterations. is also cycle limited
     (configurable?) to avoid getting stuck on infinite loops. maybe also show
     "10000c/500000c": how many cycles have been executed under the cursor vs
     the limit.
   - words under cursor can have their documentation shown. might even be
     possible to document mini notation under cursor? editor command to insert
     short doc? e.g. "dup" => "dup (x -- x x)"
   - heap view?

 - settings are probably also "powered" by a terminal display of a kind
   (keeping it simple), and contains:
   - font: face, size and codepoint sets
   - hdr/graphics settings?
   - audio settings? number of threads? I/O mapping?
   - video synth settings?
   - osc/midi setup/mapping?
   - keymap, scroll sensitivity?
   - editor modes?
   - settings import/export/migration? (possibly allow importing/exporting a
     subset)

 - editor y-expand/shrink (inspired by The Ultimate Soundtracker). helps give
   sections more or less focus. cursor line is probably y-expanded by default.

 - inline curves: you can insert a "special character" (not really a character,
   more like a keyboard shortcut) that represents a 1d curve. this curve is
   editable after you've inserted it.
   - it works inside pattern strings: length of curve (in number of character)
     doesn't matter, except for data density (just like "bd" isn't shorter than
     "piano")
   - it works inside sequence strings: length of curve (in number of character)
   - it works outside of strings: it pushes the curve object on the stack
     (length is observable, but consumers can choose how to interpret it?)
   - tecnically it's probably made with escape sequences..
   - curves can probably be painted with a lot of input methods (maybe even
     separate methods per axis): mouse, keyboard, foot pedal or tablet (osc?),
     midi?

 - maybe have other concepts similar to inline curves:
   - mini piano roll: maybe only 1-4 rows, and no "note overlap"; for small
     sequences where time isn't locked to a grid
   - mini step sequencer: you can already do step sequences with strings, but a
     mini step sequences could be: binary, 1-4 rows?

 - while it would be nice to support installed/OS fonts, and/or to load fonts
   via file dialogs, I think it's initially sufficient to only allow people to
   choose between a few "built-in" fonts. on desktop, maybe allow a font dir or
   a fonts.txt. reasons:
    - stb_truetype.h was not built with security in mind (see warning at top),
      so being a little careful with the list of fonts may be a good thing?
    - stb_truetype.h only supports TTF/OTF, but there are other font formats
      (WOFF/WOFF2).
    - support for OS/installed fonts, and/or file dialogs is complicated :)
   web could actually use its own font renderer? but there's an annoying
   problem: you can't ask the Font Loading API which glyphs are present/missing
   in a font; the current design configures which codepoint ranges we want, and
   renders the atlas up front, but codepoint ranges are typically simple and
   contains lots of unassigned codepoints and such; these are trivial to skip
   with stb_truetype.h, but impossible to reliably skip with web.

video synth engine: I'm seriously considering something more like TIC-80 than
Hydra, i.e. low-res CPU-driven, rather than high-res GPU-driven. because:
 - it feels as if the gap between low-end and high-end CPUs is way smaller than
   the gap between low-end and high-end GPUs; i.e. it's easier to inadvertently
   make a shader that causes low-end clients to drop to single-digit FPS's on
   GPUs than CPUs? conversely, it's way easier to cycle-limit a CPU-based
   "shader" (to make it fair and accessible for everybody)
 - I can't say that the TIC-80 stuff I see on FieldFxDemo (twitch) is any less
   interesting than the Hydra stuff I see, despite TIC-80 being 240x136 pixels,
   16 colors.
 - TIC-80 style is much more hands-on, where something like Hydra is more
   "functional"? in a functional shader, if you want the pixel at [42,69] to be
   white, then it needs to be part of the formula for every pixel. but
   something like TIC-80 is procedural and you can just putpixel(42,69,WHITE)
   at the end.
 - easier to do proper network sync if the CPU-based VM has limited RAM? say
   the VM has 256kB, and maybe you can even mark which pages are "long memory
   pages", then that's all that needs to be kept in sync. long memory is good
   for stuff like conway's game of life, if you want everybody to see the same
   chaotically generated glider at roughly the same time. a functional shader
   (f(x,y,time)=color) would have no "long memory" and thus no state sync.
 - it's easier to port when you don't need to compile shaders on the fly (some
   graphics APIs [like vulkan?] benefit from pre-compiled shaders). a rp2350
   port of the video synth may even be possible :) (the rp2040 can run a
   faithful doom!)
 - and.. the GPU industry smelled awful even long before they got involved with
   crypto mining and AI. the industry has always favored the rich (like
   triple-A game studios) and/or those with no cross-platform requirements
   (like crypto/AI)
 - high-end GPUs open a lot of doors. I've seen DJs on twitch do real-time
   stable diffusion (?) hallucinations based on both cam input and keywords
   from chat. but this is bleeding edge. and there are also many other things
   you can do with GPUs, like shader language live coding (shadertoy style),
   hydra-like, engines (e.g. godot). these vary a lot in their "requirements".
   so rather than try to accomodate everything in mainline-do, these are best
   integrated via a common interface or protocol like OSC and websockets?
negatives:
 - it's more "pixellated" which is not in everybody's taste (ross scott of
   accursed farms has talked about his dislike for "shimmering", although I
   don't think he dislikes pixel art in general, just the aliasing effects)
 - steals valuable CPU cycles from audio

alternative video synth engine: textured triangle soup.
 - fits into the existing cross-platform rendering engine I have in mind
   (pretty much the same as what dear imgui does; textures and triangles)
 - not pixellated/shimmering; allows for a different style
 - could perhaps fit into the existing video synth, as its own "playfield" or
   "video mode", so it can be mixed with pixellated graphics.



platforms:
 - sdl3 desktop (bsd, linux, windows, macos) using "gl" or "gpu" renderer
 - emscripten web/webgl using "gl" renderer
 - sdl3 android/gles3(?) using "gl" renderer (and/or "gpu"? dunno if it works)
renderers:
 - "gl" supports gles3/egl/webgl
 - "gpu" (via SDL3 GPU) supports vulkan/dx12/metal
ostensibly we don't need anything besides "gl" because:
 - our GPU requirements are modest
 - "gl" covers webgl on web
 - and OpenGL on desktop is cross-platform, right? ...right?
well,.. Dear ImGui also has modest requirements, yet its opengl3 backend source
has a comment about glBufferSubData() (not the most fancy OpenGL call!) leaking
memory on Windows using Intel GPU/driver. OpenGL support on Windows has always
sucked (I think?), seemingly because graphics vendors would rather concentrate
their efforts on d3d drivers? so the idea is that one of these renderers ought
to work on your computer; use "gpu" if your computer supports it (not all cards
support vulkan/dx12/metal), otherwise use "gl" on older hardware (I have a 2017
iMac running FreeBSD and it doesn't support Vulkan and likely never will, but
it has a fine CPU and I want to run Do on it).
note, I also briefly considered using SDL_Renderer, but:
 - I saw some subtle problems when trying to make a SDL_Renderer backend:
   - screen flickers in fullscreen (I don't think it was a bug in my code)
   - textures cannot be shared between multple windows
   - vertex colors must be float[4] which is a bit overkill; 32B per vertex
     instead of 20B (this is also something that can be optimized even further
     on gl/gpu renderers)
 - it has support for many backends, even software rendering, but I'm not sure
   it has much value? (look at llvmpipe if software rendering has interest?)
 - it's probably not too hard to add it again if desired (unless the the code
   drifts out of "sdl renderer territory"; with sdl renderer you have to stick
   to the basics, but with gl/gpu you have a lot more options)




rule of thumb: the software should have the same reliability as you'd expect
from a real instrument when playing live. this is more of a "soft rule", or a
guideline, or an ideal:
 - undo/redo is well-defined for a single user, but ill-defined in a multi-user
   environment. this is similar to how you're unlikely to get merge conflicts
   when you're the only committer on a repository, but the risk becomes real
   when you start adding people. thus I'm considering not having undo/redo at
   all (I don't want a ctrl+z that only works sometimes). going a little
   deeper, Do is inspired by Flok/Strudel, and Flok uses Yjs for "collaborative
   editing"; Yjs uses the "conflict-free replicated data type" (CRDT) model
   which has a "magic step" you must provide: an algorithm that resolves
   conflicts! I don't trust such magic to JustWork(tm), and even less when the
   result must be not only human-readable but also machine-readable (a 1-in-100
   glitch sounds more tolerable in a text document than in source code?). also,
   undo/redo is less useful when you already have a "pending commits" system
   like what I'm planning, because you can change your mind before committing.

